<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>US Google Trends Map</title>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://unpkg.com/topojson@3"></script>

<style>
html, body {
  margin: 0; padding: 0; width: 100%; height: 100%;
  overflow: hidden; background: white; font-family: Arial, sans-serif;
}

svg { width: 100vw; height: 100vh; }

.state { stroke: #333; stroke-width: 0.7; cursor: pointer; }
.state:hover { opacity: 0.7; }
#tooltip {
  position: absolute; background: white; border: 1px solid #aaa;
  padding: 6px 8px; font-size: 14px; pointer-events: none; display: none;
}
.label { font-size: 10px; pointer-events: none; font-weight: bold; }
.line { stroke: #555; stroke-width: 1; }
</style>
<h2 style="text-align: center;">Trending Google Searches per State</h2>

</head>
<body>
<div id="tooltip"></div>
<svg></svg>

<script>
const svg = d3.select("svg");
const tooltip = d3.select("#tooltip");
const projection = d3.geoAlbersUsa();
const path = d3.geoPath(projection);

const fipsToState = {
  "01":"US-AL","02":"US-AK","04":"US-AZ","05":"US-AR","06":"US-CA",
  "08":"US-CO","09":"US-CT","10":"US-DE","11":"US-DC","12":"US-FL",
  "13":"US-GA","15":"US-HI","16":"US-ID","17":"US-IL","18":"US-IN",
  "19":"US-IA","20":"US-KS","21":"US-KY","22":"US-LA","23":"US-ME",
  "24":"US-MD","25":"US-MA","26":"US-MI","27":"US-MN","28":"US-MS",
  "29":"US-MO","30":"US-MT","31":"US-NE","32":"US-NV","33":"US-NH",
  "34":"US-NJ","35":"US-NM","36":"US-NY","37":"US-NC","38":"US-ND",
  "39":"US-OH","40":"US-OK","41":"US-OR","42":"US-PA","44":"US-RI",
  "45":"US-SC","46":"US-SD","47":"US-TN","48":"US-TX","49":"US-UT",
  "50":"US-VT","51":"US-VA","53":"US-WA","54":"US-WV","55":"US-WI",
  "56":"US-WY"
};

//STATES TOO SMALL FOR REGULAR LABELS
const neStates = ["US-RI","US-DE","US-NJ","US-MD","US-CT","US-MA","US-VT","US-NH"];
const neOffsets = {
  "US-RI":[60,5],  "US-DE":[60,0], "US-NJ":[60,5], "US-MD":[60,10],
  "US-CT":[60,15], "US-MA":[60,-15], "US-VT":[-40,-30], "US-NH":[-10,-80]
};

Promise.all([
  fetch("trends.json").then(r => r.json()),
  fetch("https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json").then(r => r.json())
]).then(([trends, us]) => {

  const states = topojson.feature(us, us.objects.states).features;

  const padding = 50;
  //padding
  const topPadding = 50; 
  projection.fitExtent(
    [[padding, topPadding],[window.innerWidth - padding, window.innerHeight - padding]],
    topojson.feature(us, us.objects.states)
  );

  //colors
        const trendTitles = Array.from(new Set(
          Object.values(trends)
            .filter(d => d && typeof d.title === "string" && d.title.trim() !== "")
            .map(d => d.title.trim())
        ));
        //missing trend data ie wyoming, montana often
        const checkTrendData = (trend) => {
          return !trend || typeof trend.title !== "string" || trend.title.trim() === "";
        };
    //visually separate... but visible with black text
    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }
    //no gray
    //bc "No data" is gray and its confusing
    const originalPalette = d3.schemeCategory10.concat(d3.schemeSet3);
    const colorArray = shuffle(originalPalette.filter(c => {
      const grays = ["#cccccc", "#b3b3b3", "#c0c0c0", "#999999", "#808080", "#f2f2f2", "#d9d9d9", "#e6e6e6"];
      return !grays.includes(c.toLowerCase());
    }));
    const colorScale = d3.scaleOrdinal()
                         .domain(trendTitles)
                         .range(colorArray);

  //50px UP
  const mapGroup = svg.append("g").attr("transform", "translate(0,-50)"); 


  mapGroup.selectAll("path")
    .data(states)
    .join("path")
    .attr("class","state")
    .attr("d", path)
        .attr("fill", d => {
          const fips = d.id.toString().padStart(2,"0");
          const code = fipsToState[fips];
          const trend = trends[code];
          //color gray for No data
            if (checkTrendData(trend)) {
            return "#ccc"; 
          }
          return colorScale(trend.title.trim());
        })
    .on("mousemove",(event,d)=>{
      const fips = d.id.toString().padStart(2,"0");
      const code = fipsToState[fips];
      const trend = trends[code];
      const text = checkTrendData(trend) ? "No data" : trend.title;
      tooltip.style("display","block")
             .style("left",(event.pageX+10)+"px")
             .style("top",(event.pageY+10)+"px")
             .html(`<strong>${d.properties.name}</strong><br>${text}`);
    })
    .on("mouseout",()=>tooltip.style("display","none"))
    .on("click",(event,d)=>{
      const fips = d.id.toString().padStart(2,"0");
      const code = fipsToState[fips];
      const trend = trends[code];
      if (!checkTrendData(trend)) {
        const query = encodeURIComponent(trend.title.trim());
        window.open(`https://www.google.com/search?q=${query}`, '_blank');
      }
    });

  //state labels for states big enough to fit label
  states.forEach(d=>{
    const fips = d.id.toString().padStart(2,"0");
    const code = fipsToState[fips];
    const trend = trends[code];
    if(neStates.includes(code)) return;
    const centroid = path.centroid(d);
    let labelText;
    if(!trend || !trend.title || trend.title.trim()==="") {
      labelText = "No data";
    } else {
      labelText = trend.title;
    }
    mapGroup.append("text")
       .attr("x", centroid[0])
       .attr("y", centroid[1])
       .attr("class","label")
       .attr("text-anchor","middle")
       .text(labelText)
       .call(wrap, 80);
  });

  //guiding lines for new england small states
  neStates.forEach(code=>{
    const state = states.find(d=>fipsToState[d.id.toString().padStart(2,"0")]===code);
    if(!state) return;
    const centroid = path.centroid(state);
    const trend = trends[code];
    let labelText;
    if(!trend || !trend.title || trend.title.trim()==="") {
      labelText = "No data";
    } else {
      labelText = trend.title;
    }

    const [dx,dy] = neOffsets[code];
    const x = centroid[0]+dx;
    const y = centroid[1]+dy;

    mapGroup.append("line")
       .attr("x1", centroid[0])
       .attr("y1", centroid[1])
       .attr("x2", x)
       .attr("y2", y)
       .attr("class","line");

    mapGroup.append("text")
       .attr("x", x+(dx>0?5:-5))
       .attr("y", y+4)
       .attr("class","label")
       .attr("text-anchor", dx>0?"start":"end")
       .text(labelText)
       .call(wrap,120);
  });

});

function wrap(text,width){
  text.each(function(){
    const text=d3.select(this);
    const words=text.text().split(/\s+/).reverse();
    let word,line=[],lineNumber=0,lineHeight=1.1;
    const y=text.attr("y"), x=text.attr("x");
    let tspan=text.text(null).append("tspan").attr("x",x).attr("y",y);
    while(word=words.pop()){
      line.push(word); tspan.text(line.join(" "));
      if(tspan.node().getComputedTextLength()>width){
        line.pop(); tspan.text(line.join(" "));
        line=[word];
        tspan=text.append("tspan").attr("x",x).attr("y",+y+(++lineNumber*lineHeight*10)).text(word);
      }
    }
  });
}

window.addEventListener("resize",()=>location.reload());
</script>
</body>
</html>
